= Deploy and Monitor a Native Binary on Azure AppService
:author: {author-name}
:icons: font
:source-highlighter: highlight.js

== Introduction:
* Recap of the series so far
* Benefits of native compilation with GraalVM
* What to expect in terms of performance and monitoring differences

== 1: Configure Quarkus for Native Compilation
* Required dependencies and configurations
* GraalVM setup considerations
* Handling reflection and other native compilation challenges

== 2: Build the Native Binary
* Using Maven for native compilation
* Handling environment-specific configurations
* Optimizing for cloud deployment

== 3: Modify Azure AppService Configuration
* Adapting the web app configuration for native executables
* Custom startup commands
* Environment variables

== 4: Deploy the Native Binary
* Upload strategies
* Deployment verification
* Troubleshooting common issues

== 5: Compare Monitoring Metrics
* Startup time comparison
* Memory consumption differences
* Response time improvements
* CPU utilization patterns
* Side-by-side comparison charts

== 6: Optimize Monitoring for Native Applications
* Custom metrics specifically for native deployments
* Performance tuning based on metrics
* Resource allocation recommendations

== Conclusion
* JAR vs. Native comparison summary
* Best practices for monitoring Quarkus native applications
* Real-world considerations for production deployments
* Series wrap-up

== Definitions:
*	Azure AppService
*	Azure Monitor

== Resources
* xxx
